<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vtk-dicom: vtkDICOMCharacterSet Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">vtk-dicom
   &#160;<span id="projectnumber">0.8.16</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classvtkDICOMCharacterSet-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vtkDICOMCharacterSet Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Character sets.  
 <a href="classvtkDICOMCharacterSet.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="vtkDICOMCharacterSet_8h_source.html">vtkDICOMCharacterSet.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab48a086c433e697b1c7f10c5470063bb"><td class="memItemLeft" align="right" valign="top"><a id="ab48a086c433e697b1c7f10c5470063bb"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>EnumType</b> { <br />
&#160;&#160;<b>ISO_IR_6</b> = 0
, <b>ISO_IR_13</b> = 1
, <b>ISO_IR_100</b> = 8
, <b>ISO_IR_101</b> = 9
, <br />
&#160;&#160;<b>ISO_IR_109</b> = 10
, <b>ISO_IR_110</b> = 11
, <b>ISO_IR_144</b> = 12
, <b>ISO_IR_127</b> = 13
, <br />
&#160;&#160;<b>ISO_IR_126</b> = 14
, <b>ISO_IR_138</b> = 15
, <b>ISO_IR_148</b> = 16
, <b>X_LATIN6</b> = 17
, <br />
&#160;&#160;<b>ISO_IR_166</b> = 18
, <b>X_LATIN7</b> = 19
, <b>X_LATIN8</b> = 20
, <b>ISO_IR_203</b> = 21
, <br />
&#160;&#160;<b>X_LATIN9</b> = 21
, <b>X_LATIN10</b> = 22
, <b>X_EUCKR</b> = 24
, <b>X_GB2312</b> = 25
, <br />
&#160;&#160;<b>ISO_2022_IR_6</b> = 32
, <b>ISO_2022_IR_13</b> = 33
, <b>ISO_2022_IR_87</b> = 34
, <b>ISO_2022_IR_13_87</b> = 35
, <br />
&#160;&#160;<b>ISO_2022_IR_159</b> = 36
, <b>ISO_2022_IR_87_159</b> = 38
, <b>ISO_2022_IR_13_87_159</b> = 39
, <b>ISO_2022_IR_100</b> = 40
, <br />
&#160;&#160;<b>ISO_2022_IR_101</b> = 41
, <b>ISO_2022_IR_109</b> = 42
, <b>ISO_2022_IR_110</b> = 43
, <b>ISO_2022_IR_144</b> = 44
, <br />
&#160;&#160;<b>ISO_2022_IR_127</b> = 45
, <b>ISO_2022_IR_126</b> = 46
, <b>ISO_2022_IR_138</b> = 47
, <b>ISO_2022_IR_148</b> = 48
, <br />
&#160;&#160;<b>ISO_2022_IR_166</b> = 50
, <b>ISO_2022_IR_203</b> = 53
, <b>ISO_2022_IR_149</b> = 56
, <b>ISO_2022_IR_58</b> = 57
, <br />
&#160;&#160;<b>X_ISO_2022_JP</b> = 58
, <b>X_ISO_2022_JP_1</b> = 59
, <b>X_ISO_2022_JP_2</b> = 60
, <b>X_ISO_2022_JP_EXT</b> = 61
, <br />
&#160;&#160;<b>ISO_IR_192</b> = 64
, <b>GB18030</b> = 65
, <b>GBK</b> = 66
, <b>X_BIG5</b> = 67
, <br />
&#160;&#160;<b>X_EUCJP</b> = 69
, <b>X_SJIS</b> = 70
, <b>X_CP874</b> = 76
, <b>X_CP1250</b> = 80
, <br />
&#160;&#160;<b>X_CP1251</b> = 81
, <b>X_CP1252</b> = 82
, <b>X_CP1253</b> = 83
, <b>X_CP1254</b> = 84
, <br />
&#160;&#160;<b>X_CP1255</b> = 85
, <b>X_CP1256</b> = 86
, <b>X_CP1257</b> = 87
, <b>X_CP1258</b> = 88
, <br />
&#160;&#160;<b>X_KOI8</b> = 90
, <b>Unknown</b> = 255
<br />
 }</td></tr>
<tr class="separator:ab48a086c433e697b1c7f10c5470063bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa66805b165b49b9bc08b2fe5642ad59a"><td class="memItemLeft" align="right" valign="top"><a id="aa66805b165b49b9bc08b2fe5642ad59a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkDICOMCharacterSet.html#aa66805b165b49b9bc08b2fe5642ad59a">vtkDICOMCharacterSet</a> ()</td></tr>
<tr class="memdesc:aa66805b165b49b9bc08b2fe5642ad59a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an object that describes the default (ASCII) character set. <br /></td></tr>
<tr class="separator:aa66805b165b49b9bc08b2fe5642ad59a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8164a351dae05a37e7f7277a30602e57"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkDICOMCharacterSet.html#a8164a351dae05a37e7f7277a30602e57">vtkDICOMCharacterSet</a> (int k)</td></tr>
<tr class="memdesc:a8164a351dae05a37e7f7277a30602e57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a character set object from a given code.  <a href="classvtkDICOMCharacterSet.html#a8164a351dae05a37e7f7277a30602e57">More...</a><br /></td></tr>
<tr class="separator:a8164a351dae05a37e7f7277a30602e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c32c7b9d47ba8274577bccacb75f9a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkDICOMCharacterSet.html#a68c32c7b9d47ba8274577bccacb75f9a">vtkDICOMCharacterSet</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a68c32c7b9d47ba8274577bccacb75f9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a character set object from a SpecificCharacterSet value.  <a href="classvtkDICOMCharacterSet.html#a68c32c7b9d47ba8274577bccacb75f9a">More...</a><br /></td></tr>
<tr class="separator:a68c32c7b9d47ba8274577bccacb75f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc9e26f35fa2b2890ad71ceaeb6ad6d"><td class="memItemLeft" align="right" valign="top"><a id="a3bc9e26f35fa2b2890ad71ceaeb6ad6d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>vtkDICOMCharacterSet</b> (const char *name, size_t nl)</td></tr>
<tr class="separator:a3bc9e26f35fa2b2890ad71ceaeb6ad6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f11a07f4e098739ee3379f64da3792c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkDICOMCharacterSet.html#a7f11a07f4e098739ee3379f64da3792c">GetCharacterSetString</a> () const</td></tr>
<tr class="memdesc:a7f11a07f4e098739ee3379f64da3792c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate SpecificCharacterSet code values (diagnostic only).  <a href="classvtkDICOMCharacterSet.html#a7f11a07f4e098739ee3379f64da3792c">More...</a><br /></td></tr>
<tr class="separator:a7f11a07f4e098739ee3379f64da3792c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d32495bc708b48ceca834ca375fffb0"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkDICOMCharacterSet.html#a8d32495bc708b48ceca834ca375fffb0">GetDefinedTerm</a> () const</td></tr>
<tr class="memdesc:a8d32495bc708b48ceca834ca375fffb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the defined term (possible multi-valued) for this character set.  <a href="classvtkDICOMCharacterSet.html#a8d32495bc708b48ceca834ca375fffb0">More...</a><br /></td></tr>
<tr class="separator:a8d32495bc708b48ceca834ca375fffb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab015484aa87e55651e9d3b3de1366153"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkDICOMCharacterSet.html#ab015484aa87e55651e9d3b3de1366153">GetMIMEName</a> () const</td></tr>
<tr class="memdesc:ab015484aa87e55651e9d3b3de1366153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the internet MIME name for this character set.  <a href="classvtkDICOMCharacterSet.html#ab015484aa87e55651e9d3b3de1366153">More...</a><br /></td></tr>
<tr class="separator:ab015484aa87e55651e9d3b3de1366153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aabaf96ae6e19f979e8428da601b154"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkDICOMCharacterSet.html#a5aabaf96ae6e19f979e8428da601b154">GetName</a> () const</td></tr>
<tr class="memdesc:a5aabaf96ae6e19f979e8428da601b154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a name that identifies this character set.  <a href="classvtkDICOMCharacterSet.html#a5aabaf96ae6e19f979e8428da601b154">More...</a><br /></td></tr>
<tr class="separator:a5aabaf96ae6e19f979e8428da601b154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e30651f5dda860d18cb753314453462"><td class="memItemLeft" align="right" valign="top"><a id="a9e30651f5dda860d18cb753314453462"></a>
unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkDICOMCharacterSet.html#a9e30651f5dda860d18cb753314453462">GetKey</a> () const</td></tr>
<tr class="memdesc:a9e30651f5dda860d18cb753314453462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the numerical code for this character set object. <br /></td></tr>
<tr class="separator:a9e30651f5dda860d18cb753314453462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae09e8374203c072e8a0044e0f8de842a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkDICOMCharacterSet.html#ae09e8374203c072e8a0044e0f8de842a">FromUTF8</a> (const char *text, size_t l, size_t *lp=nullptr) const</td></tr>
<tr class="memdesc:ae09e8374203c072e8a0044e0f8de842a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert text from UTF-8 to this encoding.  <a href="classvtkDICOMCharacterSet.html#ae09e8374203c072e8a0044e0f8de842a">More...</a><br /></td></tr>
<tr class="separator:ae09e8374203c072e8a0044e0f8de842a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e621aba2ffe453bf903bd568add50e4"><td class="memItemLeft" align="right" valign="top"><a id="a6e621aba2ffe453bf903bd568add50e4"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>FromUTF8</b> (const std::string &amp;text) const</td></tr>
<tr class="separator:a6e621aba2ffe453bf903bd568add50e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da8f5c233a739f6e00508fc2a00d8fa"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkDICOMCharacterSet.html#a1da8f5c233a739f6e00508fc2a00d8fa">ToUTF8</a> (const char *text, size_t l, size_t *lp=nullptr) const</td></tr>
<tr class="memdesc:a1da8f5c233a739f6e00508fc2a00d8fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert text from this encoding to UTF-8.  <a href="classvtkDICOMCharacterSet.html#a1da8f5c233a739f6e00508fc2a00d8fa">More...</a><br /></td></tr>
<tr class="separator:a1da8f5c233a739f6e00508fc2a00d8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7306afdbc26456c2b4c0ea25562e4d18"><td class="memItemLeft" align="right" valign="top"><a id="a7306afdbc26456c2b4c0ea25562e4d18"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>ToUTF8</b> (const std::string &amp;text) const</td></tr>
<tr class="separator:a7306afdbc26456c2b4c0ea25562e4d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67122af1229cf110da9c20492e00e16d"><td class="memItemLeft" align="right" valign="top"><a id="a67122af1229cf110da9c20492e00e16d"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkDICOMCharacterSet.html#a67122af1229cf110da9c20492e00e16d">ConvertToUTF8</a> (const char *text, size_t l) const</td></tr>
<tr class="memdesc:a67122af1229cf110da9c20492e00e16d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obsolete method for converting to UTF8. <br /></td></tr>
<tr class="separator:a67122af1229cf110da9c20492e00e16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a702049f069a959d8df896ed22400f694"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkDICOMCharacterSet.html#a702049f069a959d8df896ed22400f694">ToSafeUTF8</a> (const char *text, size_t l) const</td></tr>
<tr class="memdesc:a702049f069a959d8df896ed22400f694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert text to UTF-8 that is safe to print to the console.  <a href="classvtkDICOMCharacterSet.html#a702049f069a959d8df896ed22400f694">More...</a><br /></td></tr>
<tr class="separator:a702049f069a959d8df896ed22400f694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acece22451a38624793b0f2f7594720a5"><td class="memItemLeft" align="right" valign="top"><a id="acece22451a38624793b0f2f7594720a5"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>ToSafeUTF8</b> (const std::string &amp;text) const</td></tr>
<tr class="separator:acece22451a38624793b0f2f7594720a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fee0d03b51b489e67d82d778fc48e5a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkDICOMCharacterSet.html#a9fee0d03b51b489e67d82d778fc48e5a">CaseFoldedUTF8</a> (const char *text, size_t l) const</td></tr>
<tr class="memdesc:a9fee0d03b51b489e67d82d778fc48e5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert text into a form suitable for case-insensitive matching.  <a href="classvtkDICOMCharacterSet.html#a9fee0d03b51b489e67d82d778fc48e5a">More...</a><br /></td></tr>
<tr class="separator:a9fee0d03b51b489e67d82d778fc48e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1646dcf0b9e2d420589f3644ed29368"><td class="memItemLeft" align="right" valign="top"><a id="ac1646dcf0b9e2d420589f3644ed29368"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>CaseFoldedUTF8</b> (const std::string &amp;text) const</td></tr>
<tr class="separator:ac1646dcf0b9e2d420589f3644ed29368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2f9b0c890405d93499303e165d5987"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkDICOMCharacterSet.html#a0c2f9b0c890405d93499303e165d5987">IsISO2022</a> () const</td></tr>
<tr class="memdesc:a0c2f9b0c890405d93499303e165d5987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if ISO 2022 escape codes are used.  <a href="classvtkDICOMCharacterSet.html#a0c2f9b0c890405d93499303e165d5987">More...</a><br /></td></tr>
<tr class="separator:a0c2f9b0c890405d93499303e165d5987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2224775c671bf74d200958a31da657"><td class="memItemLeft" align="right" valign="top"><a id="a0b2224775c671bf74d200958a31da657"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkDICOMCharacterSet.html#a0b2224775c671bf74d200958a31da657">IsISO8859</a> () const</td></tr>
<tr class="memdesc:a0b2224775c671bf74d200958a31da657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this uses an ISO 8859 code page. <br /></td></tr>
<tr class="separator:a0b2224775c671bf74d200958a31da657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe8ee69a191a82b78f127a7a7a11894"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkDICOMCharacterSet.html#a0fe8ee69a191a82b78f127a7a7a11894">IsBiDirectional</a> () const</td></tr>
<tr class="memdesc:a0fe8ee69a191a82b78f127a7a7a11894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for bidirectional character sets.  <a href="classvtkDICOMCharacterSet.html#a0fe8ee69a191a82b78f127a7a7a11894">More...</a><br /></td></tr>
<tr class="separator:a0fe8ee69a191a82b78f127a7a7a11894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92056f6e40faaaaffeede36e8d3f4b2"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkDICOMCharacterSet.html#af92056f6e40faaaaffeede36e8d3f4b2">CountBackslashes</a> (const char *text, size_t l) const</td></tr>
<tr class="memdesc:af92056f6e40faaaaffeede36e8d3f4b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of backslashes in an encoded string.  <a href="classvtkDICOMCharacterSet.html#af92056f6e40faaaaffeede36e8d3f4b2">More...</a><br /></td></tr>
<tr class="separator:af92056f6e40faaaaffeede36e8d3f4b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a801b5c801a50888930fa2b89a58522f5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkDICOMCharacterSet.html#a801b5c801a50888930fa2b89a58522f5">NextBackslash</a> (const char *text, const char *end) const</td></tr>
<tr class="memdesc:a801b5c801a50888930fa2b89a58522f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the offset to the next backslash, or to the end of the string.  <a href="classvtkDICOMCharacterSet.html#a801b5c801a50888930fa2b89a58522f5">More...</a><br /></td></tr>
<tr class="separator:a801b5c801a50888930fa2b89a58522f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae763dd56fde74838609e31bed4855e19"><td class="memItemLeft" align="right" valign="top"><a id="ae763dd56fde74838609e31bed4855e19"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (<a class="el" href="classvtkDICOMCharacterSet.html">vtkDICOMCharacterSet</a> b) const</td></tr>
<tr class="separator:ae763dd56fde74838609e31bed4855e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48532d0815b4dcc4c3ddda6796960e7b"><td class="memItemLeft" align="right" valign="top"><a id="a48532d0815b4dcc4c3ddda6796960e7b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (<a class="el" href="classvtkDICOMCharacterSet.html">vtkDICOMCharacterSet</a> b) const</td></tr>
<tr class="separator:a48532d0815b4dcc4c3ddda6796960e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e9c758baed5faf36b8e1d6e6c0dbfa"><td class="memItemLeft" align="right" valign="top"><a id="a45e9c758baed5faf36b8e1d6e6c0dbfa"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;=</b> (<a class="el" href="classvtkDICOMCharacterSet.html">vtkDICOMCharacterSet</a> a) const</td></tr>
<tr class="separator:a45e9c758baed5faf36b8e1d6e6c0dbfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a749e2055bfd2a8eb9278587334e0bd73"><td class="memItemLeft" align="right" valign="top"><a id="a749e2055bfd2a8eb9278587334e0bd73"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;=</b> (<a class="el" href="classvtkDICOMCharacterSet.html">vtkDICOMCharacterSet</a> a) const</td></tr>
<tr class="separator:a749e2055bfd2a8eb9278587334e0bd73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af713c7bba5f3c3d4b2c16244089a6fab"><td class="memItemLeft" align="right" valign="top"><a id="af713c7bba5f3c3d4b2c16244089a6fab"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (<a class="el" href="classvtkDICOMCharacterSet.html">vtkDICOMCharacterSet</a> a) const</td></tr>
<tr class="separator:af713c7bba5f3c3d4b2c16244089a6fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6912f85bb2807b73d548d457529dc85a"><td class="memItemLeft" align="right" valign="top"><a id="a6912f85bb2807b73d548d457529dc85a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;</b> (<a class="el" href="classvtkDICOMCharacterSet.html">vtkDICOMCharacterSet</a> a) const</td></tr>
<tr class="separator:a6912f85bb2807b73d548d457529dc85a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab8711d542ff308dd1f973a921b0618dc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkDICOMCharacterSet.html#ab8711d542ff308dd1f973a921b0618dc">SetGlobalDefault</a> (<a class="el" href="classvtkDICOMCharacterSet.html">vtkDICOMCharacterSet</a> cs)</td></tr>
<tr class="memdesc:ab8711d542ff308dd1f973a921b0618dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the character set to use if SpecificCharacterSet is missing.  <a href="classvtkDICOMCharacterSet.html#ab8711d542ff308dd1f973a921b0618dc">More...</a><br /></td></tr>
<tr class="separator:ab8711d542ff308dd1f973a921b0618dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11aac4afacdbf2a746a459747b4ba9bb"><td class="memItemLeft" align="right" valign="top"><a id="a11aac4afacdbf2a746a459747b4ba9bb"></a>
static <a class="el" href="classvtkDICOMCharacterSet.html">vtkDICOMCharacterSet</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetGlobalDefault</b> ()</td></tr>
<tr class="separator:a11aac4afacdbf2a746a459747b4ba9bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9142f0266098ccfeea9df0f32a8c4bc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkDICOMCharacterSet.html#ab9142f0266098ccfeea9df0f32a8c4bc">SetGlobalOverride</a> (bool b)</td></tr>
<tr class="memdesc:ab9142f0266098ccfeea9df0f32a8c4bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override the value stored in SpecificCharacterSet with the default.  <a href="classvtkDICOMCharacterSet.html#ab9142f0266098ccfeea9df0f32a8c4bc">More...</a><br /></td></tr>
<tr class="separator:ab9142f0266098ccfeea9df0f32a8c4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc69388382a59c4dabacee5c947f1c8"><td class="memItemLeft" align="right" valign="top"><a id="aefc69388382a59c4dabacee5c947f1c8"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>GlobalOverrideOn</b> ()</td></tr>
<tr class="separator:aefc69388382a59c4dabacee5c947f1c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24af3f45139dae99c1fd74e3b623fe5"><td class="memItemLeft" align="right" valign="top"><a id="ad24af3f45139dae99c1fd74e3b623fe5"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>GlobalOverrideOff</b> ()</td></tr>
<tr class="separator:ad24af3f45139dae99c1fd74e3b623fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748f3d8a92adde95f6b96e8978b10c86"><td class="memItemLeft" align="right" valign="top"><a id="a748f3d8a92adde95f6b96e8978b10c86"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>GetGlobalOverride</b> ()</td></tr>
<tr class="separator:a748f3d8a92adde95f6b96e8978b10c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Character sets. </p>
<p>This class provides the means to convert the various international text encodings used by DICOM to UTF-8 and back again.</p>
<p>During conversion to UTF-8, any codes from the original encoding that can't be converted are replaced by Unicode's "REPLACEMENT CHARACTER", which is a question mark in a black diamond. For instance, if the original encoding is ISO_IR_6 (ASCII), any octets outside of the valid ASCII range of 0 to 127 will become "REPLACEMENT CHARACTER".</p>
<p>DICOM supports a fairly small number of single-byte and multi-byte character sets. The only VRs that support these character sets are PN, LO, SH, ST, LT, and ST (all other text VRs must be ASCII). In addition to ASCII, there are twelve 8-bit single-byte encodings, three iso-2022 multi-byte encodings, and three variable-length encodings (UTF-8, GB18030, GBK).</p>
<p>In some DICOM data sets, especially old ones, the SpecificCharacterSet attribute will be missing and it might be necessary to manually specify a character set for the application to use. Use <a class="el" href="classvtkDICOMCharacterSet.html#ab8711d542ff308dd1f973a921b0618dc" title="Set the character set to use if SpecificCharacterSet is missing.">SetGlobalDefault()</a> to do so. The <a class="el" href="classvtkDICOMCharacterSet.html" title="Character sets.">vtkDICOMCharacterSet</a> constructor can take the desired character encoding as a string, where the following encodings are allowed: 'ascii', 'latin1', 'latin2', 'latin3', 'latin4', 'latin5' 'latin7', 'latin9', 'cyrillic' (iso-8859-5), 'arabic' (iso-8859-6), 'greek' (iso-8859-7), 'hebrew' (iso-8859-8), 'tis-620', 'shift-jis', 'euc-jp', 'iso-2022-jp', 'korean' (euc-kr), 'chinese' (gb2312), 'gbk', 'gb18030', 'big5', 'cp1250', 'cp1251', 'cp1252', 'cp1253', 'cp1254', 'cp1255', 'cp1256', 'cp1257', 'cp1258', and 'utf-8'. Common aliases of these character sets can also be used. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8164a351dae05a37e7f7277a30602e57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8164a351dae05a37e7f7277a30602e57">&#9670;&nbsp;</a></span>vtkDICOMCharacterSet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vtkDICOMCharacterSet::vtkDICOMCharacterSet </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a character set object from a given code. </p>
<p>The code can be any of the enumerated code values. The ISO_2022 flag can be added to any of the ISO-8859 codes to indicate that the character set allows the use of escape codes. Also note that ISO_2022_IR_87 and ISO_2022_IR_159 are combining codes that can be added to each other and to ISO_IR_13. Specifying any other codes in combination can lead to undefined results, for example "ISO_2022_IR_100 | ISO_2022_IR_101" is not permitted and "ISO_2022_IR_100" must be used instead. </p>

</div>
</div>
<a id="a68c32c7b9d47ba8274577bccacb75f9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68c32c7b9d47ba8274577bccacb75f9a">&#9670;&nbsp;</a></span>vtkDICOMCharacterSet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vtkDICOMCharacterSet::vtkDICOMCharacterSet </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a character set object from a SpecificCharacterSet value. </p>
<p>This generates an 8-bit code that uniquely identifies a DICOM character set plus its code extensions. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9fee0d03b51b489e67d82d778fc48e5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fee0d03b51b489e67d82d778fc48e5a">&#9670;&nbsp;</a></span>CaseFoldedUTF8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string vtkDICOMCharacterSet::CaseFoldedUTF8 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert text into a form suitable for case-insensitive matching. </p>
<p>This function will perform case normalization on a string by converting it to lowercase, and by normalizing the forms of lowercase characters that do not have an exact uppercase equivalent. In some cases, it might increase the length of the string. It covers modern European scripts (including Greek and Cyrillic) and latin characters used in East Asian languages. </p>

</div>
</div>
<a id="af92056f6e40faaaaffeede36e8d3f4b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af92056f6e40faaaaffeede36e8d3f4b2">&#9670;&nbsp;</a></span>CountBackslashes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int vtkDICOMCharacterSet::CountBackslashes </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the number of backslashes in an encoded string. </p>
<p>The backslash byte is sometimes present as half of a multibyte character in the Japanese and Chinese encodings. This method skips these false backslashes and counts only real backslashes. </p>

</div>
</div>
<a id="ae09e8374203c072e8a0044e0f8de842a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae09e8374203c072e8a0044e0f8de842a">&#9670;&nbsp;</a></span>FromUTF8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string vtkDICOMCharacterSet::FromUTF8 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>lp</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert text from UTF-8 to this encoding. </p>
<p>Attempt to convert from UTF-8 to this character set. Every non-convertible character will be replaced with '?'. If you pass a non-null value for the "lp" parameter, then "lp" will be set to the position in the input UTF-8 string where the first conversion error occurred, and the unconverted character will be output as &lt;U+XXXX&gt; instead of '?'. If the conversion was error-free, then "lp" will be set to the length of the input string. </p>

</div>
</div>
<a id="a7f11a07f4e098739ee3379f64da3792c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f11a07f4e098739ee3379f64da3792c">&#9670;&nbsp;</a></span>GetCharacterSetString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string vtkDICOMCharacterSet::GetCharacterSetString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate SpecificCharacterSet code values (diagnostic only). </p>
<p>This will return the same value as <a class="el" href="classvtkDICOMCharacterSet.html#a8d32495bc708b48ceca834ca375fffb0" title="Get the defined term (possible multi-valued) for this character set.">GetDefinedTerm()</a> is a defined term exists, otherwise it return the same value as <a class="el" href="classvtkDICOMCharacterSet.html#a5aabaf96ae6e19f979e8428da601b154" title="Get a name that identifies this character set.">GetName()</a> if the character set has a name, with a final fallback to the number returned by <a class="el" href="classvtkDICOMCharacterSet.html#a9e30651f5dda860d18cb753314453462" title="Get the numerical code for this character set object.">GetKey()</a> converted to a string. </p>

</div>
</div>
<a id="a8d32495bc708b48ceca834ca375fffb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d32495bc708b48ceca834ca375fffb0">&#9670;&nbsp;</a></span>GetDefinedTerm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* vtkDICOMCharacterSet::GetDefinedTerm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the defined term (possible multi-valued) for this character set. </p>
<p>If the character set permitted by the DICOM standard, this will return the defined term, otherwise the returned value will be NULL. An empty string is returned for the default character set (ISO_IR 6). Multiple values will be separated by backslashes, e.g. "\\ISO 2022 IR 58" or "ISO 2022 IR 13\\ISO 2022 IR 87". </p>

</div>
</div>
<a id="ab015484aa87e55651e9d3b3de1366153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab015484aa87e55651e9d3b3de1366153">&#9670;&nbsp;</a></span>GetMIMEName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* vtkDICOMCharacterSet::GetMIMEName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the internet MIME name for this character set. </p>
<p>The return value will be NULL if there isn't a good match between this character set and one of the MIME character sets in common use on the internet. So conversion may be necessary, either to UTF-8 or to a different encoding with a similar character repertoire. For example, "ISO 2022 IR 149" can be converted to "EUC-KR", "ISO 2022 IR 58" can can be converted to "GBK", and "ISO 2022 IR 13\\ISO 2022 IR 87" can be converted to "Shift_JIS". Note that "ISO-2022-JP" is not equivalent to DICOM's Japanese encodings since it does not allow half-width katakana or the "ISO 2022 IR 159" characters. </p>

</div>
</div>
<a id="a5aabaf96ae6e19f979e8428da601b154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aabaf96ae6e19f979e8428da601b154">&#9670;&nbsp;</a></span>GetName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* vtkDICOMCharacterSet::GetName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a name that identifies this character set. </p>
<p>For DICOM character sets, the name is based on the defined term, and for other character sets, the common name is used. If no name exists, then "Unknown" will be returned. </p>

</div>
</div>
<a id="a0fe8ee69a191a82b78f127a7a7a11894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fe8ee69a191a82b78f127a7a7a11894">&#9670;&nbsp;</a></span>IsBiDirectional()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vtkDICOMCharacterSet::IsBiDirectional </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for bidirectional character sets. </p>
<p>This is used to check for character sets that are likely to contain characters that print right-to-left, specifically Hebrew and Arabic. Note that even though some parts of unicode fall into this category, this flag is off for unicode and GB18030/GBK. </p>

</div>
</div>
<a id="a0c2f9b0c890405d93499303e165d5987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c2f9b0c890405d93499303e165d5987">&#9670;&nbsp;</a></span>IsISO2022()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vtkDICOMCharacterSet::IsISO2022 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if ISO 2022 escape codes are used. </p>
<p>If this method returns true, then escape codes can be used to switch between character sets. </p>

</div>
</div>
<a id="a801b5c801a50888930fa2b89a58522f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a801b5c801a50888930fa2b89a58522f5">&#9670;&nbsp;</a></span>NextBackslash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vtkDICOMCharacterSet::NextBackslash </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the offset to the next backslash, or to the end of the string. </p>
<p>In order to work properly, this method requires that its input is either at the beginning of the string or just after a backslash. </p>

</div>
</div>
<a id="ab8711d542ff308dd1f973a921b0618dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8711d542ff308dd1f973a921b0618dc">&#9670;&nbsp;</a></span>SetGlobalDefault()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vtkDICOMCharacterSet::SetGlobalDefault </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkDICOMCharacterSet.html">vtkDICOMCharacterSet</a>&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the character set to use if SpecificCharacterSet is missing. </p>
<p>Some DICOM files do not list a SpecificCharacterSet attribute, but nevertheless use a non-ASCII character encoding. This method can be used to specify the character set in absence of SpecificCharacterSet. If SpecificCharacterSet is present, the default will not override it unless OverrideCharacterSet is true. </p>

</div>
</div>
<a id="ab9142f0266098ccfeea9df0f32a8c4bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9142f0266098ccfeea9df0f32a8c4bc">&#9670;&nbsp;</a></span>SetGlobalOverride()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vtkDICOMCharacterSet::SetGlobalOverride </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override the value stored in SpecificCharacterSet with the default. </p>
<p>This method can be used if the SpecificCharacterSet attribute of a file is incorrect. It forces the use of the character set that was set with SetGlobalDefault. </p>

</div>
</div>
<a id="a702049f069a959d8df896ed22400f694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a702049f069a959d8df896ed22400f694">&#9670;&nbsp;</a></span>ToSafeUTF8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string vtkDICOMCharacterSet::ToSafeUTF8 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert text to UTF-8 that is safe to print to the console. </p>
<p>All control characters or unconvertible characters will be replaced by four-byte octal codes, e.g. '\033'. Backslashes will be replaced by '\134' to avoid any potential ambiguity. </p>

</div>
</div>
<a id="a1da8f5c233a739f6e00508fc2a00d8fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1da8f5c233a739f6e00508fc2a00d8fa">&#9670;&nbsp;</a></span>ToUTF8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string vtkDICOMCharacterSet::ToUTF8 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>lp</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert text from this encoding to UTF-8. </p>
<p>This will convert text to UTF-8, which is generally a lossless process for western languages but not for the CJK languages. Characters that cannot be mapped to unicode, or whose place in unicode is not known, will be printed as unicode U+FFFD which appears as a question mark in a diamond. If you pass a non-null value for the "lp" parameter, then "lp" will be set the position in the input string where the first conversion error occurred, and each unconverted byte will be output as &lt;XX&gt; (a hexadecimal code in angle brackets). If an error-free conversion was returned, then "lp" will be set to the length of the input string. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="vtkDICOMCharacterSet_8h_source.html">vtkDICOMCharacterSet.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 4 2024 20:30:16 for vtk-dicom by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
