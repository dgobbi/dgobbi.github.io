<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>vtk-dicom: Image Reader</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">vtk-dicom
   &#160;<span id="projectnumber">0.7.11</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Image Reader </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Nitty-gritty details for loading DICOM images.</p>
<h2>Overview</h2>
<p>The <a class="el" href="classvtk_d_i_c_o_m_reader.html" title="Read DICOM image files. ">vtkDICOMReader</a> converts a series of images (usually collated by <a class="el" href="classvtk_d_i_c_o_m_directory.html" title="Get information about all DICOM files within a directory. ">vtkDICOMDirectory</a>) into three outputs:</p><ol type="1">
<li>a vtkImageData object to hold the pixel data for the volume</li>
<li>a vtkMatrix4x4 to hold the position and orientation of the volume</li>
<li>a <a class="el" href="classvtk_d_i_c_o_m_meta_data.html" title="A container class for DICOM metadata. ">vtkDICOMMetaData</a> object to hold the meta-data</li>
</ol>
<p>Each slice of the output image data is generated from one of the input files (or, in the case of multi-frame images, from one frame). The slices are sorted into the correct order by the reader, so it is not necessary to sort the files beforehand. The reader also computes a 4x4 matrix, the "PatientMatrix", that can be used to convert from image data coordinates (measured in millimeters from the center of the first voxel), to DICOM patient coordinates (as described in the <a href="http://dicom.nema.org/medical/dicom/current/output/chtml/part03/sect_C.7.6.2.html">DICOM Image Plane Module</a>).</p>
<p>In order to achieve this, the reader checks the Image Position and Image Orientation that are recorded in the meta data for each slice. Then, if and only if the slices have the same orientation and the slice positions fit a line, the reader sorts the slices according to location. The vtkImageData <em>z</em> spacing is then set to the average center-to-center distance between adjacent slices.</p>
<p>In the absence of Image Position information in the meta data, or if the slices do not form a rectilinear or parallelepiped volume, then the slices are sorted only according to the Instance Number in the meta data. There is also a reader method called SortingOff() than can be called to disable sorting entirely, so that the order of the slices in the vtkImageData will reflect the order of the list of files provided to the reader.</p>
<h2>Row order</h2>
<p>DICOM images are rasterized from top to bottom, meaning that the first pixel in the file is meant to be displayed at the top left corner of the viewport. The convention for the VTK image reader classes, however, is to store the pixels in memory such that the first pixel is at the bottom left corner. To support his convention, the default behavior of the <a class="el" href="classvtk_d_i_c_o_m_reader.html" title="Read DICOM image files. ">vtkDICOMReader</a> is to flip the images while reading them so that last image row in the file becomes the first row of the vtkImageData. In this way, if the image is displayed by the vtkImageViewer, it will be displayed the right way up.</p>
<p>However, flipping the image has consequences. When the reader flips the image image, it likewise flips the PatientMatrix with respect to the ImageOrientationPatient stored in the file. Also, since a flip along one axis requires a flip along another axis in order for the coordinate system to obey the right-hand-rule, the reversal of the ordering of the rows is accompanied by a reversal of the ordering of the slices. This is done because the alternative, introducing a PatientMatrix with a negative determinant, will cause difficulties with 3D processing and display of the images.</p>
<p>Hence, unless the intent is to use <a class="el" href="classvtk_d_i_c_o_m_reader.html" title="Read DICOM image files. ">vtkDICOMReader</a> in a simple 2D display pipeline with vtkImageViewer, it is recommended to call the SetMemoryRowOrderToFileNative() method when reading the images. This will keep the keep the image in its original top-to-bottom ordering.</p>
<div class="fragment"><div class="line">vtkNew&lt;vtkDICOMReader&gt; reader;</div>
<div class="line">reader-&gt;SetFileNames(fileNameArray);</div>
<div class="line">reader-&gt;SetMemoryRowOrderToFileNative();</div>
<div class="line">reader-&gt;Update();</div>
<div class="line"></div>
<div class="line"><span class="comment">// get the matrix to use when displaying the data</span></div>
<div class="line"><span class="comment">// (this matrix provides position and orientation)</span></div>
<div class="line">vtkMatrix4x4 *matrix = reader-&gt;GetPatientMatrix();</div>
</div><!-- fragment --><h2>CT gantry tilt</h2>
<p>Certain CT scan protocols present a challenge for 3D image analysists because the slice orientation is tilted with respect to the scan direction, resulting in an acquisition volume that is a parallelepiped. This occurs because of the geometry of the CT scanner itself: traditionally, CT scanners were designed to acquire one slice at a time with the bed moving a few millimeters between slices. The CT gantry, and hence the slices, could be tilted to better align with anatomy, but tilting the bed of the scanner to match was undesirable for obvious reasons. Hence the direction in which the bed moved was not at a right angle to the slices.</p>
<p>Volume rendering techniques and many 3D filtering techniques assume a uniform, orthonormal sampling of the data. It is therefore necessary to "un-tilt" or rectify these gantry-tilted CT images. This can be done with the <a class="el" href="classvtk_d_i_c_o_m_c_t_rectifier.html" title="Prepare a CT for 3D processing. ">vtkDICOMCTRectifier</a> class, which rectifies tilted CT volumes and acts as a simple pass-through for volumes that are already rectilinear. The rectification is achieved through a simple in-plane translation and sinc interpolation of the slices. The resulting slices have the same orientation as the original slices.</p>
<div class="fragment"><div class="line">vtkNew&lt;vtkDICOMCTRectifier&gt; rectify;</div>
<div class="line">rectify-&gt;SetVolumeMatrix(reader-&gt;GetPatientMatrix());</div>
<div class="line">rectify-&gt;SetInputConnection(reader-&gt;GetOutputPort());</div>
<div class="line">rectify-&gt;Update();</div>
<div class="line"></div>
<div class="line"><span class="comment">// get the new PatientMatrix for the rectified volume</span></div>
<div class="line">vtkMatrix4x4 *matrix = rectify-&gt;GetRectifiedMatrix();</div>
</div><!-- fragment --><h2>CT and PET rescaled values</h2>
<p>Another challenge with CT images is that the pixel intensity scaling, as recorded in the RescaleSlope and RescaleIntercept attributes of the file, can vary from slice to slice. This is done to make the best use of the limited dynamic range of the analog-to-digital converter in the scanner. By default, the <a class="el" href="classvtk_d_i_c_o_m_reader.html" title="Read DICOM image files. ">vtkDICOMReader</a> will automatically detect the changes in RescaleSlope and RescaleIntercept, and will then adjust the slices so that they are all the same. This is controlled with the AutoRescaleOn()/Off() method of the reader.</p>
<p>In general, this automatic adjustment is safe for CT images, because usually it is only RescaleIntercept that varies, and it usually varies by a whole number. There is no loss of fidelity when the integer pixel value is adjusted by a whole number, as long as it remains within the range that can be represented by the datatype. For PET images, however, the RescaleSlope also varies and it is necessary to use floating-point values.</p>
<p>If accurate pixel values are required (which is the case in most medical applications), it is recommended that AutoRescaleOff() is used. The rescaling of the pixel values to "real" values should be done with the <a class="el" href="classvtk_d_i_c_o_m_apply_rescale.html" title="Convert pixels to real-world values. ">vtkDICOMApplyRescale</a> filter, which will produce pixel values as "double" (or, optionally, as "float") after applying the RescaleSlope and the RescaleIntercept for each slice.</p>
<div class="fragment"><div class="line">vtkNew&lt;vtkDICOMCTReader&gt; reader;</div>
<div class="line">reader-&gt;SetFileNames(fileNameArray);</div>
<div class="line">reader-&gt;SetMemoryRowOrderToFileNative();</div>
<div class="line">reader-&gt;AutoRescaleOff();</div>
<div class="line"></div>
<div class="line">vtkNew&lt;vtkDICOMApplyRescale&gt; rescale;</div>
<div class="line">rescale-&gt;SetInputConnection(reader-&gt;GetOutputPort());</div>
<div class="line">rescale-&gt;SetOutputScalarTypeToFloat();</div>
<div class="line">rescale-&gt;Update();</div>
</div><!-- fragment --><p>The <a class="el" href="classvtk_d_i_c_o_m_reader.html" title="Read DICOM image files. ">vtkDICOMReader</a> provides the rescaling information, along with all the other meta data, via the VTK data pipeline (i.e. via GetOutputPort()). If you use this filter together with <a class="el" href="classvtk_d_i_c_o_m_c_t_rectifier.html" title="Prepare a CT for 3D processing. ">vtkDICOMCTRectifier</a> in the same pipeline, it is recommened that this filter comes before the rectifier.</p>
<h2>Multi-dimensional images</h2>
<p>In addition to sorting slices by location, the reader attempts to detect multi-dimensional data sets. It recognizes up to 5 dimensions: <em>x</em>, <em>y</em>, <em>z</em>, <em>t</em>, and a vector dimension. This is best illustrated by example. If an MR raw-data DICOM series provides real and imaginary pixel data at each slice location, then the vtkImageData produced by the reader will have two components (real and imaginary). We interpret this as an image with a vector dimension of 2.</p>
<p>When a time dimension is present, things become interesting. The default behavior of the reader is to store adjacent time points in adjacent vtkImageData slices. This works well when the images are to be displayed slice-by-slice. It is, however, inappropriate if the vtkImageData is to be displayed as a multi-planar reformat or as a volume. For this reason, the <a class="el" href="classvtk_d_i_c_o_m_reader.html" title="Read DICOM image files. ">vtkDICOMReader</a> has a method called TimeAsVectorOn() that will cause the reader to treat each voxel as a time vector. In other words, if the DICOM data has 10 individual time slots, then the vtkImageData will have 10 components per voxel (or 30 components in the case of RGB data). By selecting a specific component or range of components when displaying the data, one can display a specific point in time.</p>
<p>Five dimensions come into play when the DICOM series has frames that are at the same location and within the same time slot. Going back to the (real,imaginary) example, if such a series of images is read after TimeAsVectorOn() is called, then the vtkImageData will have 20 components per voxel if there are 10 time slots. The 20 components can be thought of as 10 component blocks with 2 components per block. A filter like vtkImageExtractComponents can be used to extract a block of components that corresponds to a particular time slot.</p>
<p>If the behavior described in the preceding paragraphs is not desirable, then one can use the SetDesiredTimeIndex(int) method to read just one time slot, and use a set of <em>N</em> readers to read the <em>N</em> time slots as <em>N</em> separate VTK data sets.</p>
<div class="fragment"><div class="line">vtkNew&lt;vtkDICOMReader&gt; reader;</div>
<div class="line">reader-&gt;SetFileNames(filenames);</div>
<div class="line"></div>
<div class="line"><span class="comment">// read just the meta data, to get the time dimension</span></div>
<div class="line">reader-&gt;UpdateInformation();</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> numberOfTimeSlots = reader-&gt;GetTimeDimension();</div>
<div class="line"><span class="keywordflow">if</span> (numberOfTimeSlots &gt; 1)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// example: read only the final time slot</span></div>
<div class="line">  reader-&gt;SetDesiredTimeIndex(numberOfTimeSlots-1);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// update the reader</span></div>
<div class="line">reader-&gt;Update();</div>
</div><!-- fragment --><h2>Enhanced multi-frame and multi-stack files</h2>
<p>The DICOM standard allows for multiple slices (frames) per file, or even multiple stacks of slices per file. In the case of multi-frame files, each frame is assigned a position and a time slot and the frames are sorted according to the slice sorting method described in the previous section.</p>
<p>In multi-stack files there are, as one might expect, more than one rectilinear (or perhaps non-rectilinear) volume. If sorting has been turned off with the SortingOff() method, then all the frames in the file are read sequentially into vtkImageData slices. If sorting is on, however, then the reader is only able to read one stack at a time. The method SetDesiredStackID() allows one of the stacks to be chosen by name.</p>
<div class="fragment"><div class="line"><span class="comment">// for this example, &#39;filename&#39; is multi-frame, multi-stack file</span></div>
<div class="line">vtkNew&lt;vtkDICOMReader&gt; reader;</div>
<div class="line">reader-&gt;SetFileName(filename);</div>
<div class="line"></div>
<div class="line"><span class="comment">// read the meta data, get a list of stacks</span></div>
<div class="line">reader-&gt;UpdateInformation();</div>
<div class="line">vtkStringArray *stackNames = reader-&gt;GetStackIDs();</div>
<div class="line"></div>
<div class="line"><span class="comment">// specify a stack, here we assume we know the name:</span></div>
<div class="line">reader-&gt;SetDesiredStackID(<span class="stringliteral">&quot;1&quot;</span>);</div>
</div><!-- fragment --><h2>Stacks in legacy files</h2>
<p>Even though the DICOM standard only describes the use of stacks in reference to enhanced multi-frame files, the concept is also useful when working with "legacy" files that only have one slice per file (such legacy files are, in fact, still the norm while the enhanced files described in the previous section are relatively uncommon).</p>
<p>The reader defines a stack as a set of slices that have the same orientation, and whose corners are placed along straight lines in space. This allows for rectilinear and parallelepiped volumes, with the latter being necessary for the tilted-gantry CT scans discussed previously. If multiple stacks are required to capture all of the slices in series, the reader will automatically sort the slices into stacks and reader-&gt;GetStackIDs() will return an array with multiple values. In this case, the reader will name the stacks "0", "1", "2", etcetera.</p>
<p>Generally, such multi-stack series only occur for locators or for scout series. For example, a MR scout series will often have a few images for each orientation, and will therefore result in three stacks. A CT locator will be identified as a single-slice stack that occurs before the main stack.</p>
<h2>Using DICOM with MINC or NIfTI</h2>
<p>For DICOM images of the head, chest, or abdomen the <em>x</em> coordinate increases from right to left, the <em>y</em> coordinate increases from anterior to posterior, and the <em>z</em> coordinate increases from inferior to superior. This is often referred to as the LPS coordinate system, and refers to the coordinates that are achieved after the image is been transformed via the PatientMatrix. The NIfTI and MINC file formats use a coordinate system where <em>x</em> increases to the right and <em>y</em> increases to the front (anterior). Hence, the coordinate system is rotated by 180 degrees as compared to DICOM.</p>
<p>The <a class="el" href="classvtk_d_i_c_o_m_to_r_a_s.html" title="Convert DICOM orientation to RAS orientation. ">vtkDICOMToRAS</a> filter can adjust a DICOM image so that it shares the same coordinate system as MINC and NIfTI. It can also be used to do the reverse, and convert a NIfTI or MINC image to DICOM coordinates.</p>
<div class="fragment"><div class="line">vtkNew&lt;vtkDICOMToRAS&gt; converter;</div>
<div class="line">converter-&gt;SetInputConnection(reader-&gt;GetOutputPort());</div>
<div class="line">converter-&gt;SetPatientMatrix(reader-&gt;GetPatientMatrix());</div>
<div class="line">converter-&gt;SetAllowRowReordering(<span class="keyword">true</span>);</div>
<div class="line">converter-&gt;SetAllowColumnReordering(<span class="keyword">false</span>);</div>
<div class="line"></div>
<div class="line">converter-&gt;UpdateMatrix();</div>
<div class="line">vtkMatrix4x4 *matrix = converter-&gt;GetRASMatrix(); </div>
<div class="line">converter-&gt;Update();</div>
<div class="line">vtkImageData *image = converter-&gt;GetOutput();</div>
</div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Mar 11 2017 13:30:14 for vtk-dicom by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
