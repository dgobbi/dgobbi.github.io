<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>vtk-dicom: vtkDICOMCharacterSet Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">vtk-dicom
   &#160;<span id="projectnumber">0.7.7</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="classvtk_d_i_c_o_m_character_set-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vtkDICOMCharacterSet Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Character sets.  
 <a href="classvtk_d_i_c_o_m_character_set.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="vtk_d_i_c_o_m_character_set_8h_source.html">vtkDICOMCharacterSet.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab48a086c433e697b1c7f10c5470063bb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab48a086c433e697b1c7f10c5470063bb"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>EnumType</b> { <br />
&#160;&#160;<b>ISO_IR_6</b> = 0, 
<b>ISO_IR_100</b> = 1, 
<b>ISO_IR_101</b> = 2, 
<b>ISO_IR_109</b> = 3, 
<br />
&#160;&#160;<b>ISO_IR_110</b> = 4, 
<b>ISO_IR_144</b> = 5, 
<b>ISO_IR_127</b> = 6, 
<b>ISO_IR_126</b> = 7, 
<br />
&#160;&#160;<b>ISO_IR_138</b> = 8, 
<b>ISO_IR_148</b> = 9, 
<b>ISO_IR_166</b> = 10, 
<b>ISO_IR_13</b> = 11, 
<br />
&#160;&#160;<b>ISO_IR_14</b> = 12, 
<b>ISO_IR_192</b> = 13, 
<b>GB18030</b> = 14, 
<b>GBK</b> = 15, 
<br />
&#160;&#160;<b>ISO_2022_IR_58</b> = 16, 
<b>ISO_2022_IR_87</b> = 32, 
<b>ISO_2022_IR_159</b> = 64, 
<b>ISO_2022_IR_149</b> = 128, 
<br />
&#160;&#160;<b>ISO_2022</b> = 240, 
<b>Unknown</b> = 255
<br />
 }<tr class="separator:ab48a086c433e697b1c7f10c5470063bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa66805b165b49b9bc08b2fe5642ad59a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa66805b165b49b9bc08b2fe5642ad59a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtk_d_i_c_o_m_character_set.html#aa66805b165b49b9bc08b2fe5642ad59a">vtkDICOMCharacterSet</a> ()</td></tr>
<tr class="memdesc:aa66805b165b49b9bc08b2fe5642ad59a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an object that describes the default (ASCII) character set. <br /></td></tr>
<tr class="separator:aa66805b165b49b9bc08b2fe5642ad59a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8164a351dae05a37e7f7277a30602e57"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtk_d_i_c_o_m_character_set.html#a8164a351dae05a37e7f7277a30602e57">vtkDICOMCharacterSet</a> (int k)</td></tr>
<tr class="memdesc:a8164a351dae05a37e7f7277a30602e57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a character set object from a given code.  <a href="#a8164a351dae05a37e7f7277a30602e57">More...</a><br /></td></tr>
<tr class="separator:a8164a351dae05a37e7f7277a30602e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c32c7b9d47ba8274577bccacb75f9a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtk_d_i_c_o_m_character_set.html#a68c32c7b9d47ba8274577bccacb75f9a">vtkDICOMCharacterSet</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a68c32c7b9d47ba8274577bccacb75f9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a character set object from a SpecificCharacterSet value.  <a href="#a68c32c7b9d47ba8274577bccacb75f9a">More...</a><br /></td></tr>
<tr class="separator:a68c32c7b9d47ba8274577bccacb75f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc9e26f35fa2b2890ad71ceaeb6ad6d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3bc9e26f35fa2b2890ad71ceaeb6ad6d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>vtkDICOMCharacterSet</b> (const char *name, size_t nl)</td></tr>
<tr class="separator:a3bc9e26f35fa2b2890ad71ceaeb6ad6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae0be1e39df9c50da9019587c60ab7b9f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtk_d_i_c_o_m_character_set.html#ae0be1e39df9c50da9019587c60ab7b9f">GetCharacterSetString</a> () const </td></tr>
<tr class="memdesc:ae0be1e39df9c50da9019587c60ab7b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a SpecificCharacterSet value.  <a href="#ae0be1e39df9c50da9019587c60ab7b9f">More...</a><br /></td></tr>
<tr class="separator:ae0be1e39df9c50da9019587c60ab7b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7758ac72d406ce04bb28a2519e09f5d3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7758ac72d406ce04bb28a2519e09f5d3"></a>
unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtk_d_i_c_o_m_character_set.html#a7758ac72d406ce04bb28a2519e09f5d3">GetKey</a> () const </td></tr>
<tr class="memdesc:a7758ac72d406ce04bb28a2519e09f5d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the numerical code for this character set object. <br /></td></tr>
<tr class="separator:a7758ac72d406ce04bb28a2519e09f5d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a048b2be7f1c8cc757d0db38c53c895b9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtk_d_i_c_o_m_character_set.html#a048b2be7f1c8cc757d0db38c53c895b9">ConvertToUTF8</a> (const char *text, size_t l) const </td></tr>
<tr class="memdesc:a048b2be7f1c8cc757d0db38c53c895b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert text from this encoding to UTF-8.  <a href="#a048b2be7f1c8cc757d0db38c53c895b9">More...</a><br /></td></tr>
<tr class="separator:a048b2be7f1c8cc757d0db38c53c895b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7013877ffdfbefdc96eba999a6c7f38"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtk_d_i_c_o_m_character_set.html#ac7013877ffdfbefdc96eba999a6c7f38">CaseFoldedUTF8</a> (const char *text, size_t l) const </td></tr>
<tr class="memdesc:ac7013877ffdfbefdc96eba999a6c7f38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert text into a form suitable for case-insensitive matching.  <a href="#ac7013877ffdfbefdc96eba999a6c7f38">More...</a><br /></td></tr>
<tr class="separator:ac7013877ffdfbefdc96eba999a6c7f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46215dba161c427fb5e95884e694a7ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtk_d_i_c_o_m_character_set.html#a46215dba161c427fb5e95884e694a7ec">IsBiDirectional</a> () const </td></tr>
<tr class="memdesc:a46215dba161c427fb5e95884e694a7ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for bidirectional character sets.  <a href="#a46215dba161c427fb5e95884e694a7ec">More...</a><br /></td></tr>
<tr class="separator:a46215dba161c427fb5e95884e694a7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af08ab4cd91581f820b6e0152ce483859"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtk_d_i_c_o_m_character_set.html#af08ab4cd91581f820b6e0152ce483859">CountBackslashes</a> (const char *text, size_t l) const </td></tr>
<tr class="memdesc:af08ab4cd91581f820b6e0152ce483859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of backslashes in an encoded string.  <a href="#af08ab4cd91581f820b6e0152ce483859">More...</a><br /></td></tr>
<tr class="separator:af08ab4cd91581f820b6e0152ce483859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f3c8541cf30f2c5a260d5688cd8f21"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtk_d_i_c_o_m_character_set.html#a82f3c8541cf30f2c5a260d5688cd8f21">NextBackslash</a> (const char *text, const char *end) const </td></tr>
<tr class="memdesc:a82f3c8541cf30f2c5a260d5688cd8f21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the offset to the next backslash, or to the end of the string.  <a href="#a82f3c8541cf30f2c5a260d5688cd8f21">More...</a><br /></td></tr>
<tr class="separator:a82f3c8541cf30f2c5a260d5688cd8f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4bfc32d8ff512c8478d06815be65d6da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4bfc32d8ff512c8478d06815be65d6da"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (<a class="el" href="classvtk_d_i_c_o_m_character_set.html">vtkDICOMCharacterSet</a> b) const </td></tr>
<tr class="separator:a4bfc32d8ff512c8478d06815be65d6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90a7c57fea0a2e58c091b75d925069a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa90a7c57fea0a2e58c091b75d925069a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (<a class="el" href="classvtk_d_i_c_o_m_character_set.html">vtkDICOMCharacterSet</a> b) const </td></tr>
<tr class="separator:aa90a7c57fea0a2e58c091b75d925069a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c9fb74b97e141806a843a3fb682320"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72c9fb74b97e141806a843a3fb682320"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;=</b> (<a class="el" href="classvtk_d_i_c_o_m_character_set.html">vtkDICOMCharacterSet</a> a) const </td></tr>
<tr class="separator:a72c9fb74b97e141806a843a3fb682320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b59f50e2be2c78a8900443e792ca646"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b59f50e2be2c78a8900443e792ca646"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;=</b> (<a class="el" href="classvtk_d_i_c_o_m_character_set.html">vtkDICOMCharacterSet</a> a) const </td></tr>
<tr class="separator:a7b59f50e2be2c78a8900443e792ca646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59cd60597a4cce2c59a7c6957c148756"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59cd60597a4cce2c59a7c6957c148756"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (<a class="el" href="classvtk_d_i_c_o_m_character_set.html">vtkDICOMCharacterSet</a> a) const </td></tr>
<tr class="separator:a59cd60597a4cce2c59a7c6957c148756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa203147692a22c186bf24087a410c446"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa203147692a22c186bf24087a410c446"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;</b> (<a class="el" href="classvtk_d_i_c_o_m_character_set.html">vtkDICOMCharacterSet</a> a) const </td></tr>
<tr class="separator:aa203147692a22c186bf24087a410c446"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Character sets. </p>
<p>DICOM supports a fairly small number of single-byte and multi-byte character sets. The only VRs that support these character sets are PN, LO, SH, ST, LT, and ST (all other text VRs must be ASCII). In total, there is one 7-bit encoding (ASCII), eleven 8-bit single-byte encodings, three variable-length encodings (UTF-8, GB18030, GBK), and three iso-2022 multi-byte encodings. It is possible to use iso-2022 escape codes to switch between any encodings except for UTF-8 and GB18030/GBK, although only a subset of the iso-2022 escape codes are supported by DICOM. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a8164a351dae05a37e7f7277a30602e57"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vtkDICOMCharacterSet::vtkDICOMCharacterSet </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a character set object from a given code. </p>
<p>The code can be any of the enumerated code values. The ISO 2022 codes are a bitfield and they can be combined with most other codes, but they cannot be combined with ISO_IR_192, GB18030, or GBK. </p>

</div>
</div>
<a class="anchor" id="a68c32c7b9d47ba8274577bccacb75f9a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vtkDICOMCharacterSet::vtkDICOMCharacterSet </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a character set object from a SpecificCharacterSet value. </p>
<p>This generates an 8-bit code that uniquely identifies a DICOM character set plus its code extensions. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ac7013877ffdfbefdc96eba999a6c7f38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string vtkDICOMCharacterSet::CaseFoldedUTF8 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert text into a form suitable for case-insensitive matching. </p>
<p>This function will perform case normalization on a string by converting it to lowercase, and by normalizing the forms of lowercase characters that do not have an exact uppercase equivalent. In some cases, it might increase the length of the string. It covers modern European scripts (including Greek and Cyrillic) and latin characters used in East Asian languages. </p>

</div>
</div>
<a class="anchor" id="a048b2be7f1c8cc757d0db38c53c895b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string vtkDICOMCharacterSet::ConvertToUTF8 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert text from this encoding to UTF-8. </p>
<p>This will convert text to UTF-8, which is generally a lossless process for western languages but not for the CJK languages. Characters that cannot be mapped to unicode, or whose place in unicode is not known, will be printed as unicode missing-character marks. </p>

</div>
</div>
<a class="anchor" id="af08ab4cd91581f820b6e0152ce483859"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int vtkDICOMCharacterSet::CountBackslashes </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the number of backslashes in an encoded string. </p>
<p>The backslash byte is sometimes present as half of a multibyte character in the Japanese and Chinese encodings. This method skips these false backslashes and counts only real backslashes. </p>

</div>
</div>
<a class="anchor" id="ae0be1e39df9c50da9019587c60ab7b9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string vtkDICOMCharacterSet::GetCharacterSetString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a SpecificCharacterSet value. </p>
<p>The result is given as a set of backslash-separated values if more than one encoding is present. The first value may be empty to indicate that it is ASCII. Since this class uses an unsigned char for storage, the only secondary and tertiary values that can be represented are the three multi-byte ISO 2022 character sets. Therefore, if the condition "if ((GetKey() &amp; ISO_2022_OTHER) != 0)" is true, then the string returned by this method will be incomplete and only the first character set will be listed. </p>

</div>
</div>
<a class="anchor" id="a46215dba161c427fb5e95884e694a7ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vtkDICOMCharacterSet::IsBiDirectional </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for bidirectional character sets. </p>
<p>This is used to check for character sets that are likely to contain characters that print right-to-left, specifically Hebrew and Arabic. Note that even though some parts of unicode fall into this category, this flag is off for unicode and GB18030/GBK. </p>

</div>
</div>
<a class="anchor" id="a82f3c8541cf30f2c5a260d5688cd8f21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vtkDICOMCharacterSet::NextBackslash </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the offset to the next backslash, or to the end of the string. </p>
<p>In order to work properly, this method requires that its input is either at the beginning of the string or just after a backslash. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="vtk_d_i_c_o_m_character_set_8h_source.html">vtkDICOMCharacterSet.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Apr 20 2016 20:44:49 for vtk-dicom by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
